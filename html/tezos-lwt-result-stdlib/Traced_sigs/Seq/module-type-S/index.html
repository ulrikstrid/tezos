<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>S (tezos-lwt-result-stdlib.Traced_sigs.Seq.S)</title><link rel="stylesheet" href="../../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0-beta3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../../../index.html">tezos-lwt-result-stdlib</a> &#x00BB; <a href="../../index.html">Traced_sigs</a> &#x00BB; <a href="../index.html">Seq</a> &#x00BB; S</nav><header class="odoc-preamble"><h1>Module type <code><span>Seq.S</span></code></h1><p>A replacement for <a href="../../../../ocaml/Stdlib/Seq/index.html"><code>Stdlib.Seq</code></a> which</p><ul><li>is exception-safe,</li><li>includes Lwt-, result- and Lwt-result-aware traversal functions.</li></ul><p>See <code>Lwtreslib</code> for a general description of traversors and the meaning for the name suffixes. A full description is also below.</p></header><div class="odoc-content"><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../../../Bare_sigs/Seq/module-type-S/index.html">Bare_sigs.Seq.S</a></span></code></summary><div class="odoc-include"><div class="spec-doc"><p>including the OCaml's <a href="../../../../ocaml/Stdlib/Seq/index.html"><code>Stdlib.Seq</code></a> module to share the <code>Seq</code>.t type (including concrete definition) and to bring the existing functions.</p></div><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <a href="../../../../ocaml/Stdlib/Seq/index.html">Stdlib.Seq</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="../../../../ocaml/Stdlib/Seq/index.html#type-t">t</a></span> = <span><span class="type-var">'a</span> <a href="../../../../ocaml/Stdlib/Seq/index.html#type-t">Stdlib.Seq.t</a></span></span> <span class="keyword">and</span> <span><span class="keyword">type</span> <span>'a <a href="../../../../ocaml/Stdlib/Seq/index.html#type-node">node</a></span> = <span><span class="type-var">'a</span> <a href="../../../../ocaml/Stdlib/Seq/index.html#type-node">Stdlib.Seq.node</a></span></span></span></code></summary><p>The type <code>'a t</code> is a <b>delayed list</b>, i.e. a list where some evaluation is needed to access the next element. This makes it possible to build infinite sequences, to build sequences as we traverse them, and to transform them in a lazy fashion rather than upfront.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.07</li></ul><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a t</span></span><span> = <span><span class="type-var">'a</span> <a href="../../../../ocaml/Stdlib/Seq/index.html#type-t">Stdlib.Seq.t</a></span></span></code></div><div class="spec-doc"><p>The type of delayed lists containing elements of type <code>'a</code>. Note that the concrete list node <code>'a node</code> is delayed under a closure, not a <code>lazy</code> block, which means it might be recomputed every time we access it.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-node" class="anchored"><a href="#type-node" class="anchor"></a><code><span><span class="keyword">and</span> <span>'a node</span></span><span> = <span><span class="type-var">'a</span> <a href="../../../../ocaml/Stdlib/Seq/index.html#type-node">Stdlib.Seq.node</a></span></span><span> = </span></code><table><tr id="type-node.Nil" class="anchored"><td class="def variant constructor"><a href="#type-node.Nil" class="anchor"></a><code><span>| </span><span><span class="constructor">Nil</span></span></code></td></tr><tr id="type-node.Cons" class="anchored"><td class="def variant constructor"><a href="#type-node.Cons" class="anchor"></a><code><span>| </span><span><span class="constructor">Cons</span> <span class="keyword">of</span> <span class="type-var">'a</span> * <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A fully-evaluated list node, either empty or containing an element and a delayed tail.</p><span class="comment-delim">*)</span></td></tr></table></div></div><div class="odoc-spec"><div class="spec value" id="val-empty" class="anchored"><a href="#val-empty" class="anchor"></a><code><span><span class="keyword">val</span> empty : <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>The empty sequence, containing no elements.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-return" class="anchored"><a href="#val-return" class="anchor"></a><code><span><span class="keyword">val</span> return : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>The singleton sequence containing only the given element.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-map" class="anchored"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>map f seq</code> returns a new sequence whose elements are the elements of <code>seq</code>, transformed by <code>f</code>. This transformation is lazy, it only applies when the result is traversed.</p><p>If <code>seq = [1;2;3]</code>, then <code>map f seq = [f 1; f 2; f 3]</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-filter" class="anchored"><a href="#val-filter" class="anchor"></a><code><span><span class="keyword">val</span> filter : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Remove from the sequence the elements that do not satisfy the given predicate. This transformation is lazy, it only applies when the result is traversed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-filter_map" class="anchored"><a href="#val-filter_map" class="anchor"></a><code><span><span class="keyword">val</span> filter_map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Apply the function to every element; if <code>f x = None</code> then <code>x</code> is dropped; if <code>f x = Some y</code> then <code>y</code> is returned. This transformation is lazy, it only applies when the result is traversed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-flat_map" class="anchored"><a href="#val-flat_map" class="anchor"></a><code><span><span class="keyword">val</span> flat_map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Map each element to a subsequence, then return each element of this sub-sequence in turn. This transformation is lazy, it only applies when the result is traversed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_left" class="anchored"><a href="#val-fold_left" class="anchor"></a><code><span><span class="keyword">val</span> fold_left : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Traverse the sequence from left to right, combining each element with the accumulator using the given function. The traversal happens immediately and will not terminate on infinite sequences.</p><p>Also see <code>List</code>.fold_left</p></div></div><div class="odoc-spec"><div class="spec value" id="val-iter" class="anchored"><a href="#val-iter" class="anchor"></a><code><span><span class="keyword">val</span> iter : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Iterate on the sequence, calling the (imperative) function on every element. The traversal happens immediately and will not terminate on infinite sequences.</p></div></div></details></div><p>in-monad, preallocated empty/nil</p><div class="odoc-spec"><div class="spec value" id="val-empty_e" class="anchored"><a href="#val-empty_e" class="anchor"></a><code><span><span class="keyword">val</span> empty_e : <span><span>(<span><span class="type-var">'a</span> <a href="#type-t">t</a></span>, <span class="type-var">'trace</span>)</span> <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-empty_s" class="anchored"><a href="#val-empty_s" class="anchor"></a><code><span><span class="keyword">val</span> empty_s : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-empty_es" class="anchored"><a href="#val-empty_es" class="anchor"></a><code><span><span class="keyword">val</span> empty_es : <span><span><span>(<span><span class="type-var">'a</span> <a href="#type-t">t</a></span>, <span class="type-var">'trace</span>)</span> <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-nil_e" class="anchored"><a href="#val-nil_e" class="anchor"></a><code><span><span class="keyword">val</span> nil_e : <span><span>(<span><span class="type-var">'a</span> <a href="#type-node">node</a></span>, <span class="type-var">'trace</span>)</span> <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-nil_s" class="anchored"><a href="#val-nil_s" class="anchor"></a><code><span><span class="keyword">val</span> nil_s : <span><span><span class="type-var">'a</span> <a href="#type-node">node</a></span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-nil_es" class="anchored"><a href="#val-nil_es" class="anchor"></a><code><span><span class="keyword">val</span> nil_es : <span><span><span>(<span><span class="type-var">'a</span> <a href="#type-node">node</a></span>, <span class="type-var">'trace</span>)</span> <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_left_e" class="anchored"><a href="#val-fold_left_e" class="anchor"></a><code><span><span class="keyword">val</span> fold_left_e : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'trace</span>)</span> <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'trace</span>)</span> <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span></span></code></div><div class="spec-doc"><p>Similar to <a href="#val-fold_left"><code>fold_left</code></a> but wraps the traversal in <a href="../../../../result/Result/index.html"><code>Result</code></a>. The traversal is interrupted if one of the step returns an <code>Error _</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_left_s" class="anchored"><a href="#val-fold_left_s" class="anchor"></a><code><span><span class="keyword">val</span> fold_left_s : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p>Similar to <a href="#val-fold_left"><code>fold_left</code></a> but wraps the traversing in <a href="../../../../lwt/Lwt/index.html"><code>Lwt</code></a>. Each step of the traversal is started after the previous one has resolved. The traversal is interrupted if one of the promise is rejected.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_left_es" class="anchored"><a href="#val-fold_left_es" class="anchor"></a><code><span><span class="keyword">val</span> fold_left_es : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'trace</span>)</span> <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'trace</span>)</span> <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p>Similar to <a href="#val-fold_left"><code>fold_left</code></a> but wraps the traversing in <code>result Lwt.t</code>. Each step of the traversal is started after the previous one resolved. The traversal is interrupted if one of the step is rejected or is fulfilled with <code>Error _</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-iter_e" class="anchored"><a href="#val-iter_e" class="anchor"></a><code><span><span class="keyword">val</span> iter_e : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(unit, <span class="type-var">'trace</span>)</span> <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(unit, <span class="type-var">'trace</span>)</span> <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span></span></code></div><div class="spec-doc"><p>Similar to <a href="#val-iter"><code>iter</code></a> but wraps the iteration in <a href="../../../../result/Result/index.html"><code>Result</code></a>. The iteration is interrupted if one of the step returns an <code>Error _</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-iter_s" class="anchored"><a href="#val-iter_s" class="anchor"></a><code><span><span class="keyword">val</span> iter_s : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p>Similar to <a href="#val-iter"><code>iter</code></a> but wraps the iteration in <a href="../../../../lwt/Lwt/index.html"><code>Lwt</code></a>. Each step of the iteration is started after the previous one resolved. The iteration is interrupted if one of the promise is rejected.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-iter_es" class="anchored"><a href="#val-iter_es" class="anchor"></a><code><span><span class="keyword">val</span> iter_es : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(unit, <span class="type-var">'trace</span>)</span> <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(unit, <span class="type-var">'trace</span>)</span> <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p>Similar to <a href="#val-iter"><code>iter</code></a> but wraps the iteration in <code>result Lwt.t</code>. Each step of the iteration is started after the previous one resolved. The iteration is interrupted if one of the promise is rejected of fulfilled with an <code>Error _</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-iter_ep" class="anchored"><a href="#val-iter_ep" class="anchor"></a><code><span><span class="keyword">val</span> iter_ep : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(unit, <span class="type-var">'trace</span>)</span> <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(unit, <span><span class="type-var">'trace</span> list</span>)</span> <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p>Similar to <a href="#val-iter"><code>iter</code></a> but wraps the iteration in <code>result Lwt.t</code>. All the steps of the iteration are started concurrently. The promise <code>iter_ep</code> resolves once all the promises of the traversal resolve. At this point it either:</p><ul><li>is rejected if at least one of the promises is, otherwise</li><li>is fulfilled with <code>Error _</code> if at least one of the promises is, otherwise</li><li>is fulfilled with <code>Ok ()</code> if all the promises are.</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-iter_p" class="anchored"><a href="#val-iter_p" class="anchor"></a><code><span><span class="keyword">val</span> iter_p : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p>Similar to <a href="#val-iter"><code>iter</code></a> but wraps the iteration in <a href="../../../../lwt/Lwt/index.html"><code>Lwt</code></a>. All the steps of the iteration are started concurrently. The promise <code>iter_p f s</code> is resolved only once all the promises of the iteration are. At this point it is either fulfilled if all promises are, or rejected if at least one of them is.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-map_e" class="anchored"><a href="#val-map_e" class="anchor"></a><code><span><span class="keyword">val</span> map_e : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'b</span>, <span class="type-var">'trace</span>)</span> <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'b</span> <a href="#type-t">t</a></span>, <span class="type-var">'trace</span>)</span> <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span></span></code></div><div class="spec-doc"><p>Similar to <a href="#val-map"><code>map</code></a> but wraps the transformation in <a href="../../../../result/Result/index.html"><code>Result</code></a>. The traversal is interrupted if any of the application returns an <code>Error _</code>.</p><p>Note that, unlike <a href="#val-map"><code>map</code></a>, <code>map_e</code> is not lazy: it applies the transformation immediately to all the elements of the sequence (unless it is interrupted by an <code>Error _</code>) and does not terminate on infinite sequences (again, unless interrupted). Moreover <code>map_e</code> is not tail-recursive.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-map_s" class="anchored"><a href="#val-map_s" class="anchor"></a><code><span><span class="keyword">val</span> map_s : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p>Similar to <a href="#val-map"><code>map</code></a> but wraps the transformation in <a href="../../../../lwt/Lwt/index.html"><code>Lwt</code></a>. Each transformation is done sequentially, only starting once the previous one has resolved. The traversal is interrupted if any of the promise is rejected.</p><p>Note that, unlike <a href="#val-map"><code>map</code></a>, <code>map_s</code> is not lazy: it applies the transformation eagerly to all the elements of the sequence (unless interrupted by a rejection) and does not terminate on infinite sequences (again, unless interrupted). Moreover <code>map_s</code> is not tail-recursive.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-map_es" class="anchored"><a href="#val-map_es" class="anchor"></a><code><span><span class="keyword">val</span> map_es : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'b</span>, <span class="type-var">'trace</span>)</span> <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span><span class="type-var">'b</span> <a href="#type-t">t</a></span>, <span class="type-var">'trace</span>)</span> <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p>Similar to <a href="#val-map"><code>map</code></a> but wraps the transformation in <code>result Lwt.t</code>. Each transformation is done sequentially, only starting once the previous one has resolved. The traversal is interrupted if any of the promise is rejected or fulfilled with an <code>Error _</code>.</p><p>Note that, unlike <a href="#val-map"><code>map</code></a>, <code>map_es</code> is not lazy: it applies the transformation eagerly to all the elements of the sequence (unless interrupted by rejection or an <code>Error _</code>) and does not terminate on infinite sequences (again, unless interrupted). Moreover <code>map_es</code> is not tail-recursive.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-map_ep" class="anchored"><a href="#val-map_ep" class="anchor"></a><code><span><span class="keyword">val</span> map_ep : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'b</span>, <span class="type-var">'trace</span>)</span> <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span><span class="type-var">'b</span> <a href="#type-t">t</a></span>, <span><span class="type-var">'trace</span> list</span>)</span> <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p>Similar to <a href="#val-map"><code>map</code></a> but wraps the transformation in <code>result Lwt</code>. All the transformations are done concurrently. The promise <code>map_p f s</code> resolves once all the promises of the traversal resolve. At this point it is rejected if any of the promises are, and otherwise it is resolved with <code>Error _</code> if any of the promises are, and otherwise it is fulfilled (if all the promises are).</p><p>Note that, unlike <a href="#val-map"><code>map</code></a>, <code>map_ep</code> is not lazy: it applies the transformation eagerly to all the elements of the sequence and does not terminate on infinite sequences. Moreover <code>map_p</code> is not tail-recursive.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-map_p" class="anchored"><a href="#val-map_p" class="anchor"></a><code><span><span class="keyword">val</span> map_p : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p>Similar to <a href="#val-map"><code>map</code></a> but wraps the transformation in <a href="../../../../lwt/Lwt/index.html"><code>Lwt</code></a>. All the transformations are done concurrently. The promise <code>map_p f s</code> resolves once all the promises of the traversal resolve. At this point it is fulfilled if all the promises are, and it is rejected if any of them are.</p><p>Note that, unlike <a href="#val-map"><code>map</code></a>, <code>map_p</code> is not lazy: it applies the transformation eagerly to all the elements of the sequence and does not terminate on infinite sequences. Moreover <code>map_p</code> is not tail-recursive.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-filter_e" class="anchored"><a href="#val-filter_e" class="anchor"></a><code><span><span class="keyword">val</span> filter_e : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(bool, <span class="type-var">'trace</span>)</span> <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <a href="#type-t">t</a></span>, <span class="type-var">'trace</span>)</span> <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span></span></code></div><div class="spec-doc"><p>Similar to <a href="#val-filter"><code>filter</code></a> but wraps the transformation in <code>result</code>. Note that, unlike <a href="#val-filter"><code>filter</code></a>, <code>filter_e</code> is not lazy: it applies the transformation immediately and does not terminate on infinite sequences. Moreover <code>filter_e</code> is not tail-recursive.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-filter_s" class="anchored"><a href="#val-filter_s" class="anchor"></a><code><span><span class="keyword">val</span> filter_s : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>bool <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p>Similar to <a href="#val-filter"><code>filter</code></a> but wraps the transformation in <a href="../../../../lwt/Lwt/index.html#type-t"><code>Lwt.t</code></a>. Each test of the predicate is done sequentially, only starting once the previous one has resolved. Note that, unlike <a href="#val-filter"><code>filter</code></a>, <code>filter_s</code> is not lazy: it applies the transformation immediately and does not terminate on infinite sequences. Moreover <code>filter_s</code> is not tail-recursive.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-filter_es" class="anchored"><a href="#val-filter_es" class="anchor"></a><code><span><span class="keyword">val</span> filter_es : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(bool, <span class="type-var">'trace</span>)</span> <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span><span class="type-var">'a</span> <a href="#type-t">t</a></span>, <span class="type-var">'trace</span>)</span> <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p>Similar to <a href="#val-filter"><code>filter</code></a> but wraps the transformation in <code>result Lwt.t</code>. Each test of the predicate is done sequentially, only starting once the previous one has resolved. Note that, unlike <a href="#val-filter"><code>filter</code></a>, <code>filter_es</code> is not lazy: it applies the transformation immediately and does not terminate on infinite sequences. Moreover <code>filter_es</code> is not tail-recursive.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-filter_map_e" class="anchored"><a href="#val-filter_map_e" class="anchor"></a><code><span><span class="keyword">val</span> filter_map_e : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'b</span> option</span>, <span class="type-var">'trace</span>)</span> <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'b</span> <a href="#type-t">t</a></span>, <span class="type-var">'trace</span>)</span> <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span></span></code></div><div class="spec-doc"><p>Similar to <a href="#val-filter_map"><code>filter_map</code></a> but within <code>result</code>. Not lazy and not tail-recursive.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-filter_map_s" class="anchored"><a href="#val-filter_map_s" class="anchor"></a><code><span><span class="keyword">val</span> filter_map_s : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> option</span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p>Similar to <a href="#val-filter_map"><code>filter_map</code></a> but within <code>Lwt.t</code>. Not lazy and not tail-recursive.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-filter_map_es" class="anchored"><a href="#val-filter_map_es" class="anchor"></a><code><span><span class="keyword">val</span> filter_map_es : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span><span class="type-var">'b</span> option</span>, <span class="type-var">'trace</span>)</span> <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span><span class="type-var">'b</span> <a href="#type-t">t</a></span>, <span class="type-var">'trace</span>)</span> <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p>Similar to <a href="#val-filter_map"><code>filter_map</code></a> but within <code>result Lwt.t</code>. Not lazy and not tail-recursive.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-find" class="anchored"><a href="#val-find" class="anchor"></a><code><span><span class="keyword">val</span> find : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p><code>find f t</code> is <code>Some x</code> where <code>x</code> is the first item in <code>t</code> such that <code>f x</code>. It is <code>None</code> if there are no such element. It does not terminate if the sequence is infinite and the predicate is always false.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-find_e" class="anchored"><a href="#val-find_e" class="anchor"></a><code><span><span class="keyword">val</span> find_e : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(bool, <span class="type-var">'trace</span>)</span> <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> option</span>, <span class="type-var">'trace</span>)</span> <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span></span></code></div><div class="spec-doc"><p><code>find_e f t</code> is similar to <a href="#val-find"><code>find</code></a> but wraps the search within <code>result</code>. Specifically, <code>find_e f t</code> is either</p><ul><li><code>Ok (Some x)</code> if forall <code>y</code> before <code>x</code> <code>f y = Ok false</code> and <code>f x = Ok true</code>,</li><li><code>Error e</code> if there exists <code>x</code> such that forall <code>y</code> before <code>x</code> <code>f y = Ok false</code> and <code>f x = Error e</code>,</li><li><code>Ok None</code> otherwise and <code>t</code> is finite,</li><li>an expression that never returns otherwise.</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-find_s" class="anchored"><a href="#val-find_s" class="anchor"></a><code><span><span class="keyword">val</span> find_s : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>bool <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> option</span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>find_s f t</code> is similar to <a href="#val-find"><code>find</code></a> but wrapped within <code>Lwt.t</code>. The search is identical to <code>find_e</code> but each predicate is applied when the previous one has resolved.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-find_es" class="anchored"><a href="#val-find_es" class="anchor"></a><code><span><span class="keyword">val</span> find_es : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(bool, <span class="type-var">'trace</span>)</span> <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span><span class="type-var">'a</span> option</span>, <span class="type-var">'trace</span>)</span> <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>find_es f t</code> is similar to <a href="#val-find"><code>find</code></a> but wrapped within <code>result Lwt.t</code>. The search is identical to <code>find_e</code> but each predicate is applied when the previous one has resolved.</p></div></div></details></div><div class="odoc-spec"><div class="spec type" id="type-trace" class="anchored"><a href="#type-trace" class="anchor"></a><code><span><span class="keyword">type</span> <span>'error trace</span></span></code></div><div class="spec-doc"><p><code>'error trace</code> is intended to be substituted by a type provided by a <code>Trace</code> module (<code>with type 'error trace := 'error Trace.trace</code>)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-iter_ep" class="anchored"><a href="#val-iter_ep" class="anchor"></a><code><span><span class="keyword">val</span> iter_ep : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(unit, <span><span class="type-var">'error</span> <a href="#type-trace">trace</a></span>)</span> <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(unit, <span><span class="type-var">'error</span> <a href="#type-trace">trace</a></span>)</span> <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p>Similar to <a href="#val-iter"><code>iter</code></a> but wraps the iteration in <code>result Lwt.t</code>. All the steps of the iteration are started concurrently. The promise <code>iter_ep</code> resolves once all the promises of the traversal resolve. At this point it either:</p><ul><li>is rejected if at least one of the promises is, otherwise</li><li>is fulfilled with <code>Error _</code> if at least one of the promises is, otherwise</li><li>is fulfilled with <code>Ok ()</code> if all the promises are.</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-map_ep" class="anchored"><a href="#val-map_ep" class="anchor"></a><code><span><span class="keyword">val</span> map_ep : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'b</span>, <span><span class="type-var">'error</span> <a href="#type-trace">trace</a></span>)</span> <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span><span class="type-var">'b</span> <a href="#type-t">t</a></span>, <span><span class="type-var">'error</span> <a href="#type-trace">trace</a></span>)</span> <a href="../../../../ocaml/Stdlib/index.html#type-result">Stdlib.result</a></span> <a href="../../../../lwt/Lwt/index.html#type-t">Lwt.t</a></span></span></code></div><div class="spec-doc"><p>Similar to <a href="#val-map"><code>map</code></a> but wraps the transformation in <code>result Lwt</code>. All the transformations are done concurrently. The promise <code>map_ep f s</code> resolves once all the promises of the traversal resolve. At this point it is rejected if any of the promises are, and otherwise it is resolved with <code>Error _</code> if any of the promises are, and otherwise it is fulfilled (if all the promises are).</p><p>Note that, unlike <a href="#val-map"><code>map</code></a>, <code>map_ep</code> is not lazy: it applies the transformation eagerly to all the elements of the sequence and does not terminate on infinite sequences. Moreover <code>map_ep</code> is not tail-recursive.</p></div></div></div></body></html>